装饰模式笔记
参考文章：http://blog.csdn.net/zhshulin/article/details/38665187
         http://www.cnblogs.com/ASPNET2008/archive/2008/06/15/1222724.html
         http://lavasoft.blog.51cto.com/62575/90853/
概念
   装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。
   但是纯粹的装饰模式很难找到，大多数的装饰模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰模式改变接口，
   增加新的方法。半透明的装饰模式是介于装饰模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，
   也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。
   大多数的装饰模式实际上是半透明的装饰模式，这样的装饰模式也称做半装饰、半适配器模式。
要解决的问题
     动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。
     不改变接口的前提下，增强所考虑的类的性能。
     何时使用：
        1）需要扩展一个类的功能，或给一个类增加附加责任。
        2）需要动态的给一个对象增加功能，这些功能可以再动态地撤销。
        3）需要增加一些基本功能的排列组合而产生的非常大量的功能，从而使继承变得不现实。
原理
装饰模式使用被装饰类的一个子类的实例，把客户端的调用委派到被装饰类，装饰模式的关键在于这种扩展是完全透明的。
角色
   抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。
   具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类
   装饰角色(Decorator)：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口
   具体装饰角色(ConcreteDecorator)：负责给构件对象“贴上”附加的责任
类图
    ![Image text](https://github.com/zhouzhaohui10001/designPattern/raw/master/images/decorator.png)