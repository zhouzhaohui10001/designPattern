装饰模式笔记
参考文章：http://blog.csdn.net/zhshulin/article/details/38665187
         http://www.cnblogs.com/ASPNET2008/archive/2008/06/15/1222724.html
         http://lavasoft.blog.51cto.com/62575/90853/
概念
   装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。
   但是纯粹的装饰模式很难找到，大多数的装饰模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰模式改变接口，
   增加新的方法。半透明的装饰模式是介于装饰模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，
   也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。
   大多数的装饰模式实际上是半透明的装饰模式，这样的装饰模式也称做半装饰、半适配器模式。
要解决的问题
     动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。(理解动态添加)
     不改变接口的前提下，增强所考虑的类的性能。
     何时使用：
        1）需要扩展一个类的功能，或给一个类增加附加责任。
        2）需要动态的给一个对象增加功能，这些功能可以再动态地撤销。
        3）需要增加一些基本功能的排列组合而产生的非常大量的功能，从而使继承变得不现实。
原理
装饰模式使用被装饰类的一个子类的实例，把客户端的调用委派到被装饰类，装饰模式的关键在于这种扩展是完全透明的。
角色
   抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。
   具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类
   装饰角色(Decorator)：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口
   具体装饰角色(ConcreteDecorator)：负责给构件对象“贴上”附加的责任
类图
    ![Image text](https://github.com/zhouzhaohui10001/designPattern/raw/master/images/decorator.png)

具体案例:有存储在数据库中的新闻,有存储在XML文件中的新闻(一般都是推荐新闻,内容比较少)。
        在没有接触设计模式时,都是针对具体实现编程,读取数据库新闻时直接写一个基于数据库的方法,
        读取推荐新闻时再写一个基于XML的方法,两种方法之间没有任何的关系.当时觉的这样实现也没什么不好。
        可是你总会发现这两种方法在实现上有很多相同的地方,都是读取出一个新闻标题集合来绑定数据源,
        只是取数据源的方法不同而已。为了方便管理,我们可以定义一个统一的接口来约束这两种方法。
        这种做法也足够满足读取不同载体的新闻要求。可是如果在读取新闻时要做其它的操作呢?
        例如:给读取出来的新闻的人气加一。这个时候我们就要修改原程序,这样有背于"对扩展开放,对修改关闭"的编程原则。
        如何解决呢?这就是装饰者模式出场的时候了。

     装饰者模式 ：动态地将责任附加到对象上.若要扩展功能,装饰者提供了比继承更有弹性的替代方案。

 问题: 说装饰者模式比用继承会更富有弹性,在类图中不是一样用到了继承了吗?
     说明:装饰者和被装饰者之间必须是一样的类型,也就是要有共同的超类。在这里应用继承并不是实现方法的复制,
     而是实现类型的匹配。因为装饰者和被装饰者是同一个类型,因此装饰者可以取代被装饰者,
     这样就使被装饰者拥有了装饰者独有的行为。根据装饰者模式的理念,我们可以在任何时候,实现新的装饰者增加新的行为。
     如果是用继承,每当需要增加新的行为时,就要修改原程序了。
 说了一些装饰者模式的类图和概念,下面就要讲新闻模块和装饰者模式的关联了。
    例如:在展示新闻的同时给读取出来的新闻的人气加一,同时把新闻标题加入到RSS中,如果是用继承,
    就要往超类中增加相应的方法,如果是一个新增行为还是可以忍受的,如果此模块有不断增加业务的可能,
    那是不是要每次都要修改原程序呢?我想所有的朋友都不希望这样做。
    我们希望当有新的行为时才往旧对象上加,是在运行时加,并不是一开始就加