工厂模式笔记
参考文章：https://www.zhihu.com/question/24843188?sort=created (知乎三楼的回答非常经典)
         http://www.jianshu.com/p/03519d5e47b6


1.简单工厂模式
    简单工厂模式（simple factory）是类的创建模式，又叫静态工厂方法（static factory method）模式。
    简单工厂模式就是由一个工厂类根据传入的参数决定创建哪一种的产品类。
    简单工厂模式中定义一个抽象类，抽象类中声明公共的特征及属性，抽象子类继承自抽象类，去实现具体的操作。
    工厂类根据外界需求，在工厂类中创建对应的抽象子类实例并传给外界，而对象的创建是由外界决定的。
    外界只需要知道抽象子类对应的参数即可，而不需要知道抽象子类的创建过程，在外界使用时甚至不用引入抽象子类。
    简单工厂模式将抽象子类的创建，和关于抽象子类相关的业务逻辑分离，降低对象间的耦合度。由于工厂类只是为外界创建对象，
    所以并不需要实例化工厂类对象，只需要为外界提供类方法即可。外界需要什么类型的抽象子类，只需要传递对应的参数即可。
    外界不需要知道具体的抽象子类，只需要使用抽象类即可。
    简单工厂模式主要包含三部分：
        工厂类：根据外界的需求，决定创建并返回哪个具体的抽象子类。
        抽象类：定义抽象子类所需的属性和方法，子类通过继承自抽象类获得这些方法。
        抽象子类：继承自抽象类，是具体操作的实现者，根据需求重写父类继承过来的方法。
    简单工厂模式主要适用于抽象子类的业务逻辑相同，但具体实现不同的情况。不同的操作子类执行同样的方法，最后的结果却是不同的，
    这也是多态的一种表现方式(行为功能相似)
    示例：简单的加减乘除的基础运算例子当作需求
    明显的弊端：增加抽象子类后 工厂类需要修改  不符合开闭原则
2.工厂方法模式
   工厂方法模式和简单工厂模式十分类似，大致结构是基本类似的。不同在于工厂方法模式对工厂类进行了进一步的抽象，
   将之前的一个工厂类抽象成了抽象工厂和工厂子类，抽象工厂定义一个创建抽象子类的接口，
   抽象工厂的子类实现这些接口并决定实例化哪个抽象子类。工厂子类决定着创建哪个抽象子类，外界决定着创建哪种工厂子类，
   抽象子类和工厂子类是一一对应的。很好的解决了简单工厂模式的弊端 遵循了开闭原则单工厂模式代码。
   会有一个问题，就是如果新增加其他运算功能，需要创建一个抽象子类，但是还需要修改工厂类中的代码逻辑，
   这种设计是不符合开放封闭原则的。开放封闭原则对于修改是关闭的，对于扩展是开放的。
   而且将所有的操作子类的判断和实例化都由一个工厂类完成，如果业务比较复杂会导致工厂类负担较重。

   原理：
   工厂方法模式将之前负责生成具体抽象子类的工厂类，抽象为工厂抽象类和工厂子类组成的一系列类。每创建一个抽象子类，
   就需要创建一个工厂子类，并且一一对应，由工厂子类去生成对应的抽象子类，由外界使用方来决定生成哪个工厂子类。
   这样在增加新的需求时，就不需要对工厂抽象类进行修改，而是对应新增的抽象子类创建对应的工厂子类即可。
    类图：
    ![Image text](https://github.com/zhouzhaohui10001/designPattern/raw/master/images/factoryMethod.png)


3.抽象工厂模式
